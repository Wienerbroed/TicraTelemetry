<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Create</title>
<link rel="stylesheet" href="styles/styles.css">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  /* ---------- TABLE STYLING ---------- */
  #tableContainer {
    display: flex;
    justify-content: center;
    margin-top: 20px;
  }

  table#bigTable {
    border-collapse: collapse;
    margin: 0 auto;
    width: auto;      /* dynamic width */
    min-width: 300px;
    max-width: 95%;
  }

  th, td {
    border: 2px solid #555; /* darker lines for distinction */
    padding: 5px 8px;
    text-align: center;
    min-width: 40px;
  }

  th {
    background: #eee;
  }

  th.user-header, th.total-header {
    writing-mode: vertical-rl;
    transform: rotate(180deg);
    white-space: nowrap;
    padding: 5px 10px;
  }

  #totalChartContainer {
    margin-top: 20px;
    display: flex;
    justify-content: center;
  }

  #totalChart {
    display: block;
  }

</style>
</head>
<body>
<header>
  <div class="navbar">
    <a href="index.html"><img src="images/ticra.png" alt="Home" class="nav-icon"></a>
    <a href="graspStart.html">GraspGUI</a>
    <a href="pool.html">Pool</a>
  </div>
</header>

<h1>Create usage</h1>

<div>
  <label>Start date: <input type="date" id="startDate"></label>
  <label>End date: <input type="date" id="endDate"></label>
  <label>Employee type:
    <select id="employeeType"></select>
  </label>
  <button onclick="applyFilters()">Apply</button>
</div>

<div id="tableContainer">
  <table id="bigTable">
    <thead></thead>
    <tbody></tbody>
  </table>
</div>

<div id="totalChartContainer">
  <canvas id="totalChart"></canvas>
</div>

<script>
let FULL_EVENTS = [];
let FILTERED_EVENTS = [];
let USER_ORDER = [];
const COLORS = ['#4caf50','#2196f3','#ff9800','#f44336','#9c27b0','#00bcd4','#ffeb3b','#795548'];

// ---------- LOAD DATA ----------
async function loadData() {
  const res = await fetch('/create');
  const data = await res.json();

  FULL_EVENTS = data.rawEvents.map(doc => ({
    user: doc.user_name ?? "unknown",
    selection: doc.payload.operation ?? "unknown",
    employee_type: doc.employee_type ?? "unknown",
    time_stamp: doc.time_stamp
  }));

  const end = new Date();
  const start = new Date();
  start.setDate(end.getDate() - 10);

  document.getElementById('startDate').value = start.toISOString().split('T')[0];
  document.getElementById('endDate').value = end.toISOString().split('T')[0];

  buildEmployeeTypeFilter(data.employeeTypes);
  applyFilters();
}

// ---------- FILTERS ----------
function buildEmployeeTypeFilter(types) {
  const sel = document.getElementById('employeeType');
  sel.innerHTML = '<option value="">All</option>';
  types.forEach(t => sel.appendChild(Object.assign(document.createElement('option'), { value: t, textContent: t })));
}

function applyFilters() {
  const emp = document.getElementById('employeeType').value;
  const s = document.getElementById('startDate').value;
  const e = document.getElementById('endDate').value;

  FILTERED_EVENTS = FULL_EVENTS.filter(ev => {
    if (emp && ev.employee_type !== emp) return false;
    const t = new Date(ev.time_stamp);
    if (s && t < new Date(s+'T00:00:00')) return false;
    if (e && t > new Date(e+'T23:59:59')) return false;
    return true;
  });

  renderTable(FILTERED_EVENTS);
}

// ---------- RENDER TABLE ----------
function renderTable(events) {
  const perUser = {};
  const selections = [...new Set(events.map(e => e.selection))].sort();
  
  const allUsers = [...new Set(events.map(e => e.user))];
  allUsers.forEach(u => perUser[u] = {});

  events.forEach(e => {
    perUser[e.user][e.selection] = (perUser[e.user][e.selection] ?? 0) + 1;
  });

  // Only users with at least 1 value
  const usersWithData = allUsers.filter(u => selections.some(sel => (perUser[u][sel] ?? 0) > 0));

  if(USER_ORDER.length === 0 || USER_ORDER.length !== usersWithData.length) {
    USER_ORDER = [...usersWithData];
  } else {
    USER_ORDER = USER_ORDER.filter(u => usersWithData.includes(u));
  }

  drawTable(perUser, selections, usersWithData);
  drawTotalChart(perUser, selections, usersWithData);
  makeRowsSortable(perUser, selections);
}

// ---------- DRAW TABLE ----------
function drawTable(perUser, selections, users) {
  const thead = document.querySelector('#bigTable thead');
  const tbody = document.querySelector('#bigTable tbody');
  thead.innerHTML = '';
  tbody.innerHTML = '';

  // HEADER
  const headerRow = document.createElement('tr');
  headerRow.appendChild(createHeader('Operation'));
  USER_ORDER.forEach(u => {
    const th = createHeader(u);
    th.classList.add('user-header');
    headerRow.appendChild(th);
  });
  ['TOTAL','AVERAGE','MOST USED'].forEach(label => {
    const th = createHeader(label);
    th.classList.add('total-header');
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);

  // column max for heatmap
  const columnMax = {};
  USER_ORDER.forEach(u => columnMax[u] = Math.max(...selections.map(sel => perUser[u]?.[sel] ?? 0), 0));

  // Draw rows
  selections.forEach(sel => {
    const tr = document.createElement('tr');
    tr.dataset.operation = sel;
    tr.appendChild(createHeader(sel));

    let total = 0;
    USER_ORDER.forEach(u => {
      const val = perUser[u]?.[sel] ?? 0;
      total += val;
      const g = columnMax[u] > 0 ? Math.round(255 - (val / columnMax[u]) * 100) : 255;
      tr.appendChild(createCell(val,false,`rgb(${g},255,${g})`));
    });

    const avg = (total / USER_ORDER.length).toFixed(2);
    tr.appendChild(createCell(total,true));
    tr.appendChild(createCell(avg,true));

    const maxVal = Math.max(...USER_ORDER.map(u => perUser[u]?.[sel] ?? 0));
    const mostUsed = USER_ORDER.filter(u => (perUser[u]?.[sel]??0) === maxVal && maxVal>0).length;
    tr.appendChild(createCell(mostUsed,true));

    tbody.appendChild(tr);
  });
}

// ---------- DRAW TOTAL PIE ----------
function drawTotalChart(perUser, selections, users) {
  const totals = selections.map(sel => USER_ORDER.reduce((sum,u)=>sum+(perUser[u]?.[sel]??0),0));
  const ctx = document.getElementById('totalChart');

  // double size
  const size = Math.min(900, 100 + selections.length * 100);
  ctx.width = size;
  ctx.height = size;

  const chartCtx = ctx.getContext('2d');
  if(window.totalChartInstance) window.totalChartInstance.destroy();
  window.totalChartInstance = new Chart(chartCtx,{
    type:'pie',
    data:{labels: selections, datasets:[{data: totals, backgroundColor: COLORS}]},
    options:{
      plugins:{legend:{display:true, position:'bottom'}},
      responsive:false,
      animation:false
    }
  });
}

// ---------- COLUMN SORTING BY ROW ----------
const rowSortStates = {};
function makeRowsSortable(perUser, selections) {
  const tbody = document.querySelector('#bigTable tbody');
  const rows = Array.from(tbody.querySelectorAll('tr'));
  rows.forEach(row => {
    const sel = row.dataset.operation;
    row.style.cursor = 'pointer';
    if (!(sel in rowSortStates)) rowSortStates[sel] = 0;

    row.onclick = () => {
      rowSortStates[sel] = (rowSortStates[sel] + 1) % 3;
      const state = rowSortStates[sel];

      if (state === 0) {
        USER_ORDER = [...new Set(FILTERED_EVENTS.map(e => e.user))].sort();
      } else if (state === 1) {
        const paired = USER_ORDER.map(u => ({user:u, value: perUser[u]?.[sel] ?? 0}));
        paired.sort((a,b) => b.value - a.value);
        USER_ORDER = paired.map(p => p.user);
      } else if (state === 2) {
        const paired = USER_ORDER.map(u => ({user:u, value: perUser[u]?.[sel] ?? 0}));
        paired.sort((a,b) => a.value - b.value);
        USER_ORDER = paired.map(p => p.user);
      }

      renderTable(FILTERED_EVENTS);
    };
  });
}

// ---------- HELPERS ----------
function createHeader(text){ const th=document.createElement('th'); th.textContent=text; return th;}
function createCell(v,bold=false,bg=null){ const td=document.createElement('td'); td.textContent=v; if(bold) td.style.fontWeight='bold'; if(bg) td.style.background=bg; return td;}

// ---------- INIT ----------
loadData();
</script>

<footer>
  Â© TICRA foundation
</footer>
</body>
</html>
