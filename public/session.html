<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Session Viewer</title>
<link rel="stylesheet" href="styles/styles.css">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script type="module" src="scripts/utils.js"></script>
<style>
  tr.sortable { cursor: pointer; }
  th.rotate { writing-mode: vertical-rl; transform: rotate(180deg); }
  .heatmap-max { background-color: #ffd966; }
  .sticky { position: sticky; top: 0; background: white; z-index: 2; }
</style>
</head>
<body>

<header>
  <div class="navbar">
    <a href="index.html"><img src="images/ticra.png" alt="Home" class="nav-icon"></a>
    <a href="data.html">Datapool</a>
  </div>
</header>

<h1>Session Viewer</h1>

<form id="sessionForm">
  <label>Event Type:
    <select id="eventTypeSelect"><option value="">Select Event Type</option></select>
  </label>

  <label>Employee / Employee Type:
    <select id="employeeSelect"><option value="">All</option></select>
  </label>

  <label>Start Time:
    <input type="datetime-local" id="startTime">
  </label>

  <label>End Time:
    <input type="datetime-local" id="endTime">
  </label>

  <button type="submit">Apply</button>
</form>

<div id="tableContainerWrapper">
  <div id="tableContainer"></div>
</div>

<div id="totalChartContainer" class="chart-container" style="position:relative; height:400px;">
  <canvas id="totalChart"></canvas>
</div>

<footer>
  Â© TICRA foundation
</footer>

<script type="module">
import { 
  setDefaultDateRange, fetchJson, createCell, sortTableByRow, 
  populateDropdown, applyStickyColumns, renderBarChart
} from './scripts/utils.js';

const eventTypeSelect = document.getElementById("eventTypeSelect");
const employeeSelect = document.getElementById("employeeSelect");
const startInput = document.getElementById("startTime");
const endInput = document.getElementById("endTime");
const form = document.getElementById("sessionForm");
const tableContainer = document.getElementById("tableContainer");
const totalChartCanvas = document.getElementById("totalChart");

let chartDataStore = {};
let sortState = {};
let chartInstance;

setDefaultDateRange('startTime','endTime',10);

async function initDropdowns() {
  await populateDropdown('eventTypeSelect','/sessionTypes','Select Event Type');

  // Only fetch users once
  const employeeTypes = await fetchJson('/employeeTypes');
  const users = await fetchJson('/users');

  employeeSelect.innerHTML = `<option value="">All</option>`;

  if(employeeTypes.length){
    const group = document.createElement("optgroup");
    group.label = "Employee Types";
    employeeTypes.forEach(t => {
      const opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      opt.dataset.type = "employeeType";
      group.appendChild(opt);
    });
    employeeSelect.appendChild(group);
  }

  if(users.length){
    const uniqueUsers = [...new Set(users)];
    const group = document.createElement("optgroup");
    group.label = "Employees";
    uniqueUsers.forEach(u => {
      const opt = document.createElement("option");
      opt.value = u;
      opt.textContent = u;
      opt.dataset.type = "user";
      group.appendChild(opt);
    });
    employeeSelect.appendChild(group);
  }

  // Fetch sessions for initial view
  fetchSessions();
}

initDropdowns();

form.addEventListener('submit', e=>{
  e.preventDefault();
  fetchSessions();
});

function createRotatedHeader(text, sticky=false, isUser=false){
  const th = document.createElement("th");
  th.classList.add("rotate");
  if(sticky) th.classList.add("sticky");
  if(isUser) th.classList.add("user-cell");
  const div = document.createElement("div");
  div.textContent = text;
  th.appendChild(div);
  return th;
}

function formatSecondsToHMS(sec){
  const h = Math.floor(sec/3600).toString().padStart(2,'0');
  const m = Math.floor((sec%3600)/60).toString().padStart(2,'0');
  const s = Math.floor(sec%60).toString().padStart(2,'0');
  return `${h}:${m}:${s}`;
}

function applyColumnHeatmap(table) {
  const tbody = table.querySelector('tbody');
  const rows = Array.from(tbody.querySelectorAll('tr'));
  if (!rows.length) return;

  const headerCells = table.querySelectorAll('thead th');
  let firstUserColIndex = 0;
  for (let i = 0; i < headerCells.length; i++) {
    if (headerCells[i].classList.contains('user-cell')) {
      firstUserColIndex = i;
      break;
    }
  }

  for (let col = firstUserColIndex; col < headerCells.length; col++) {
    const values = rows.map(r => parseFloat(r.children[col].dataset.sort)||0);
    const maxVal = Math.max(...values);
    rows.forEach(r=>{
      const td = r.children[col];
      td.classList.remove('heatmap-max');
      if(td.dataset.sort && parseFloat(td.dataset.sort)===maxVal && maxVal>0) td.classList.add('heatmap-max');
    });
  }
}

function attachSortableRows(table){
  const headerCells = table.querySelectorAll('thead th');
  let firstDataColIndex = 0;
  for(let i=0;i<headerCells.length;i++){
    if(headerCells[i].classList.contains('user-cell')){
      firstDataColIndex=i;
      break;
    }
  }
  table.querySelectorAll('tbody tr').forEach(tr=>{
    tr.classList.add('sortable');
    tr.addEventListener('click',()=>{sortTableByRow(table,tr,sortState,firstDataColIndex); applyColumnHeatmap(table);});
  });
}

// ---------------- TABLE ----------------
function renderTable(perEmployee){
  tableContainer.innerHTML="";
  const selectedValue = employeeSelect.value || null;
  const selectedOption = employeeSelect.querySelector(`option[value="${selectedValue}"]`);
  const isType = selectedOption?.dataset.type==='employeeType';

  if(!selectedValue) renderMultiUserTable(perEmployee);        // All
  else if(isType) renderMultiUserTable(perEmployee, selectedValue); // Employee type table (same as before)
  else renderSingleUserTable(perEmployee[selectedValue]);      // Individual employee sessions
}

// ---------------- MULTI USER TABLE ----------------
function renderMultiUserTable(perEmployee, filterType=null){
  let users = Object.keys(perEmployee).sort();
  if(filterType) users = users.filter(u=> u_type_matches(u, filterType));

  const allTabs = [...new Set(Object.values(perEmployee).flatMap(sess=>sess.map(s=>s.tab)))].sort();
  if(!allTabs.length){ tableContainer.innerHTML="<p>No sessions found.</p>"; return; }

  const table = document.createElement("table");
  const thead = document.createElement("thead");
  const tbody = document.createElement("tbody");

  const headerRow = document.createElement("tr");
  headerRow.appendChild(createRotatedHeader("Tab", true));
  headerRow.appendChild(createRotatedHeader("TOTAL", true));
  headerRow.appendChild(createRotatedHeader("AVERAGE", true));
  users.forEach(u=>headerRow.appendChild(createRotatedHeader(u,false,true)));
  thead.appendChild(headerRow);

  allTabs.forEach((tab,idx)=>{
    const tr = document.createElement("tr");
    tr.dataset.tab = tab;
    tr.classList.add(idx%2===0?'eventtype-row-white':'eventtype-row-gray');

    tr.appendChild(createCell(tab,false,null,'operation-cell'));

    const counts = users.map(u=>{
      return perEmployee[u].reduce((sum,s)=> s.tab===tab?sum+s.durationSeconds:sum,0);
    });

    const total = counts.reduce((a,b)=>a+b,0);
    const avg = counts.length?total/counts.length:0;

    tr.appendChild(createCell(formatSecondsToHMS(total),false,null,'summary-cell'));
    tr.appendChild(createCell(formatSecondsToHMS(avg),false,null,'summary-cell'));

    counts.forEach(val=>{
      const td = createCell(formatSecondsToHMS(val),false,null,'user-cell');
      td.dataset.sort=val;
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(thead);
  table.appendChild(tbody);
  tableContainer.appendChild(table);
  applyStickyColumns(table,3);
  attachSortableRows(table);
  applyColumnHeatmap(table);
}

// ---------------- SINGLE USER TABLE ----------------
function renderSingleUserTable(sessions){
  if(!sessions.length){ 
    tableContainer.innerHTML="<p>No sessions found.</p>"; 
    return; 
  }

  const tabs = [...new Set(sessions.map(s=>s.tab))].sort();
  const table = document.createElement("table");
  const thead = document.createElement("thead");
  const tbody = document.createElement("tbody");

  const sessionIds = [...new Set(sessions.map(s=>s.session_id))].sort();

  // --- HEADER ---
  const headerRow = document.createElement("tr");
  headerRow.appendChild(createRotatedHeader("Tab", true));
  headerRow.appendChild(createRotatedHeader("TOTAL", true));      // 2nd column for heatmap
  headerRow.appendChild(createRotatedHeader("AVERAGE", true));    // 3rd column for heatmap
  sessionIds.forEach(id => headerRow.appendChild(createRotatedHeader(id,false,true)));
  thead.appendChild(headerRow);

  // --- BODY ---
  tabs.forEach((tab,idx)=>{
    const tr = document.createElement("tr");
    tr.dataset.tab=tab;
    tr.classList.add(idx%2===0?'eventtype-row-white':'eventtype-row-gray');
    
    tr.appendChild(createCell(tab,false,null,'operation-cell'));

    // Calculate total for the tab across all sessions
    let total=0;
    const sessionValues = sessionIds.map(id=>{
      const matchingSessions = sessions.filter(s=>s.tab===tab && s.session_id===id);
      const val = matchingSessions.reduce((sum,s)=>sum+s.durationSeconds,0);
      total += val;
      return val;
    });

    // --- TOTAL & AVERAGE columns first ---
    tr.appendChild(createCell(formatSecondsToHMS(total),false,null,'summary-cell'));               // 2nd column
    tr.appendChild(createCell(formatSecondsToHMS(total/sessionIds.length),false,null,'summary-cell')); // 3rd column

    // --- session columns ---
    sessionValues.forEach(val=>{
      const td = createCell(formatSecondsToHMS(val),false,null,'user-cell');
      td.dataset.sort = val;
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(thead);
  table.appendChild(tbody);
  tableContainer.appendChild(table);
  
  applyStickyColumns(table,3);   // sticky for first 3 columns
  attachSortableRows(table);
  applyColumnHeatmap(table);     // now heatmap will apply correctly to 2nd & 3rd columns
}

// ---------------- FETCH ----------------
async function fetchSessions(){
  const selectedEvent = eventTypeSelect.value;
  if(!selectedEvent) return;

  const selectedValue = employeeSelect.value || null;
  let url = `/session?eventType=${encodeURIComponent(selectedEvent)}&startTime=${encodeURIComponent(startInput.value)}&endTime=${encodeURIComponent(endInput.value)}`;

  const selectedOption = employeeSelect.querySelector(`option[value="${selectedValue}"]`);
  const isType = selectedOption?.dataset.type==='employeeType';

  if(isType) url+=`&employee_type=${encodeURIComponent(selectedValue)}`;
  else if(selectedValue) url+=`&user_name=${encodeURIComponent(selectedValue)}`;

  const data = await fetchJson(url);
  const sessions = data.sessions || [];

  const perEmployee = {};
  sessions.forEach(s=>{
    const user = s.user_name || "Unknown";
    if(!perEmployee[user]) perEmployee[user]=[];
    perEmployee[user].push(s);
  });

  chartDataStore=perEmployee;
  renderTable(perEmployee);
  renderChart();
}

// ---------------- CHART ----------------
function renderChart(){
  const perEmployee=chartDataStore;
  if(!perEmployee) return;
  const labels = [...new Set(Object.values(perEmployee).flatMap(sess=>sess.map(s=>s.tab)))].sort();
  const totals = labels.map(tab=>Object.keys(perEmployee).reduce((sum,u)=>sum+(perEmployee[u].reduce((a,s)=>s.tab===tab?a+s.durationSeconds:a,0)),0));
  const colors = labels.map(_=>`rgb(${Math.random()*200},${Math.random()*200},${Math.random()*200})`);
  if(chartInstance) chartInstance.destroy();
  chartInstance = renderBarChart(totalChartCanvas, labels, totals, colors,{responsive:true,animation:false,maintainAspectRatio:false,scales:{y:{beginAtZero:true}}});
}

// ---------------- UTILITY ----------------
function u_type_matches(userName, typeName){
  // placeholder, replace with real mapping if needed
  return true; 
}
</script>

</body>
</html>